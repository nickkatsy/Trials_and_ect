
from pulp import LpMaximize, LpProblem, LpStatus, lpSum, LpVariable
import warnings
warnings.filterwarnings('ignore')




from pylab import dot, random
n = 50
a = 2. * random(n) - 1.
B = 2. * random((n, n)) - 1.
f = lambda: a[i] + dot(B[i], x)
objective = lambda x: max([f(i, x) for i in range(n)])



def solve_minmax(n, a, B, x_min=None, x_max=None):
    x = pulp.LpVariable.dicts("x", range(n + 1), x_min, x_max)
    lp_prob = pulp.LpProblem("Minmax Problem", pulp.LpMinimize)
    lp_prob += pulp.lpSum([x[n]]), "Minimize_the_maximum"

    for i in range(n):
        label = "Max_constraint_%d" % i
        dot_B_x = pulp.lpSum([B[i][j] * x[j] for j in range(n)])
        condition = pulp.lpSum([x[n]]) >= a[i] + dot_B_x
        lp_prob += condition, label

    lp_prob.writeLP("MinmaxProblem.lp")  # optional
    lp_prob.solve()

    print("Status:", pulp.LpStatus[lp_prob.status])
    for v in lp_prob.variables():
        print(v.name, "=", v.varValue)
    print("Total Cost =", pulp.value(lp_prob.objective))
    




def solve_random_minmax(n, solver):
    x = pulp.LpVariable.dicts("x", range(n + 1), -42, +42)
    lp_prob = pulp.LpProblem("Compute internal torques", pulp.LpMinimize)
    lp_prob += pulp.lpSum([x[n]]), "Minimize_the_maximum"
    a, B = 2 * pylab.random(n) - 1., 2 * pylab.random((n, n)) - 1.
    for i in range(n):
        label = "Max_constraint_%d" % i
        dot_B_x = pulp.lpSum([B[i][j] * x[j] for j in range(n)])
        condition = pulp.lpSum([x[n]]) >= a[i] + dot_B_x
        lp_prob += condition, label
    lp_prob.solve(solver)


model = LpProblem(name="small-problem", sense=LpMaximize)


x = LpVariable(name="x", lowBound=0)
y = LpVariable(name="y", lowBound=0)


expression = 2 * x + 4 * y
type(expression)


constraint = 2 * x + 4 * y >= 8
type(constraint)





model += (2 * x + y <= 20, "red_constraint")
model += (4 * x - 5 * y >= -10, "blue_constraint")
model += (-x + 2 * y >= -2, "yellow_constraint")
model += (-x + 5 * y == 15, "green_constraint")


obj_func = x + 2 * y
model += obj_func

model += lpSum([x, 2 * y])

print(model)


status = model.solve()


print(f"status: {model.status}, {LpStatus[model.status]}")


print(f"objective: {model.objective.value()}")


for var in model.variables():
 print(f"{var.name}: {var.value()}")



for name, constraint in model.constraints.items():
     print(f"{name}: {constraint.value()}")


model.variables



model.variables()[0] is x

model.variables()[1] is y


model.solver


model = LpProblem(name="resource-allocation", sense=LpMaximize)

# Define the decision variables
x = {i: LpVariable(name=f"x{i}", lowBound=0) for i in range(1, 5)}

# Add constraints
model += (lpSum(x.values()) <= 50, "manpower")
model += (3 * x[1] + 2 * x[2] + x[3] <= 100, "material_a")
model += (x[2] + 2 * x[3] + 3 * x[4] <= 90, "material_b")

# Set the objective
model += 20 * x[1] + 12 * x[2] + 40 * x[3] + 25 * x[4]

# Solve the optimization problem
status = model.solve()

# Get the results
print(f"status: {model.status}, {LpStatus[model.status]}")
print(f"objective: {model.objective.value()}")

for var in x.values():
    print(f"{var.name}: {var.value()}")

for name, constraint in model.constraints.items():
    print(f"{name}: {constraint.value()}")




model = LpProblem(name="resource-allocation", sense=LpMaximize)

# Define the decision variables
x = {i: LpVariable(name=f"x{i}", lowBound=0) for i in range(1, 5)}
y = {i: LpVariable(name=f"y{i}", cat="Binary") for i in (1, 3)}

# Add constraints
model += (lpSum(x.values()) <= 50, "manpower")
model += (3 * x[1] + 2 * x[2] + x[3] <= 100, "material_a")
model += (x[2] + 2 * x[3] + 3 * x[4] <= 90, "material_b")

M = 100
model += (x[1] <= y[1] * M, "x1_constraint")
model += (x[3] <= y[3] * M, "x3_constraint")
model += (y[1] + y[3] <= 1, "y_constraint")

# Set objective
model += 20 * x[1] + 12 * x[2] + 40 * x[3] + 25 * x[4]

# Solve the optimization problem
status = model.solve()

print(f"status: {model.status}, {LpStatus[model.status]}")
print(f"objective: {model.objective.value()}")

for var in model.variables():
    print(f"{var.name}: {var.value()}")

for name, constraint in model.constraints.items():
    print(f"{name}: {constraint.value()}")
